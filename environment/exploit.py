from enum import Enum
from typing import List, Optional
from uuid import uuid4

from utils.singleton import Singleton


class ExploitCategory(Enum):
    NONE = 0,
    AUTH_MANIPULATION = 1,
    REMOTE_EXECUTION = 2


class Exploit:
    def __init__(self, id: str = "", services: List[str] = None, category: ExploitCategory = ExploitCategory.NONE) -> None:
        if not id:
            self._id = str(uuid4())
        else:
            self._id = id

        if not services:
            self._services = []
        else:
            self._services = services

        self._category = category

    @property
    def id(self) -> str:
        return self._id

    @property
    def services(self) -> List[str]:
        return self._services

    @property
    def category(self) -> ExploitCategory:
        return self._category


class ExploitStore(metaclass=Singleton):
    def __init__(self):
        self._by_id = {}
        self._by_service = {}
        self._by_category = {}

    def add_exploit(self, *exploits: Exploit) -> None:
        for exploit in exploits:
            # Exploit already in store, do nothing
            if exploit.id in self._by_id:
                return

            self._by_id[exploit.id] = [exploit]

            for service in exploit.services:
                if service not in self._by_service:
                    self._by_service[service] = []

                self._by_service[service].append(exploit)

            if exploit.category not in self._by_category:
                self._by_category[exploit.category] = []

            self._by_category[exploit.category].append(exploit)

    def get_exploit(self, id: str = "", service: str = "", category: ExploitCategory = ExploitCategory.NONE) -> Optional[List[Exploit]]:
        candidate_sets = []

        if id:
            candidate_sets.append(set(self._by_id.get(id, [])))

        if service:
            candidate_sets.append(set(self._by_service.get(service, [])))

        if category != ExploitCategory.NONE:
            candidate_sets.append(set(self._by_category.get(category, [])))

        if not candidate_sets:
            return []
        else:
            return list(set.intersection(*candidate_sets))
