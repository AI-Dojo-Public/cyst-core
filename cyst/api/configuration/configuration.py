# Because we are operating on dataclasses, the initialization order precludes us from having some default initialized
# value, which is a real shame (though understandable)
from copy import copy
from dataclasses import dataclass, field
from uuid import uuid4
from typing import Self

"""
Provides an API to configure all aspects of the simulation engine.

Available to: creator, models
Hidden from:  agents
"""


class ConfigItem:
    """
    A superclass of a configuration items.

    Most of the configuration items have an instantiated counterpart produced by the platform. To tie these two object
    classes together, the configuration item has three identification properties: ref, name, and id.

    :param ref: A unique identification of a given configuration item. This parameter is primarily used for referencing
        this configuration from other configurations, usually when a configuration of a particular item is shared among
        multiple other configuration items. Unless there is a good reason to set it explicitly, it is best to let it be
        autogenerated. By default, UUIDs are used.
    :type ref: str

    :param name: An identifier of the object produced from the configuration item. It should be unique among siblings
        within the same parent. As with the ref parameters, it is best to let it be autogenerated, as the system will
        try to come up with a memorable name. In case of name clash among siblings, a suffix is added to the name to
        distinguish different objects. Note that the name is often not accessible through CYST API, except for service
        names that are currently used for message routing and exploit evaluation.
    :type name: str

    :param id: An identifier of the object that is unique within the whole simulation. Unless you have a very good
        reason, you should let it be autogenerated. The id is automatically constructed with the dot notation to
        express the parent-child hierarchy. Note that the id is generally not accessible through CYST API, as it is
        considered an implementation detail that is used for management of simulation components.
    :type id: str
    """
    ref: str
    name: str
    id: str

    # TODO Nested configurations and their copies
    def __call__(self, ref: str | None = None, name: str = "", id: str = "") -> Self:
        """
        Create a copy of a configuration item with a new ref id, name, or id. With this, a configuration item can be
        used as a template to repeat repetitions.

        Example:
            .. code-block:: python

            local_password_auth = AuthenticationProviderConfig(
                provider_type=AuthenticationProviderType.LOCAL,
                token_type=AuthenticationTokenType.PASSWORD,
                token_security=AuthenticationTokenSecurity.SEALED,
                timeout=30
            )

            ssh_provider = local_password_auth(name="openssh_local_pwd_auth")

        :param ref: A new ref id of the configuration item. If none is provided, it is autogenerated. The system does
            not check for duplicate refs, so if you use an already present ref, it will likely end in strange errors
            down the line.
        :type ref: str | None

        :param name: A new name for the resulting object. If none is provided, it is autogenerated.
        :type name: str

        :param id: A new id for the resulting object. It is generally better to not provide an id as it can have
            unintended consequences. It will be autogenerated if none is provided.
        :type id: str

        :return: A copy of a config item.

        """
        new_one = copy(self)
        if ref:
            new_one.ref = ref
        else:
            new_one.ref = str(uuid4())

        if name:
            new_one.name = name

        if id:
            new_one.id = id

        return new_one
